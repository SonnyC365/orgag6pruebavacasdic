// Importaciones de las Librerias
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>
#include <EEPROM.h>

// Pines de Salida
const int PIN_SALA = 3;
const int PIN_COMEDOR = 5;
const int PIN_COCINA = 6;
const int PIN_BANO = 9;
const int PIN_HAB = 10;
const int PIN_FAN = 11;  // Pin de PWM (potenciometro)
const int pinIN1=12;
const int pinIN2=13;
const int PIN_SERVO = 4;

// Objetos
LiquidCrystal_I2C lcd(0x27, 16, 2);
Servo puertaServo;


// Variables Globales a Utilizar
String comando = "";
int velocidadFan = 0;
bool puertaAbierta = false;
String nombreEscena = "Manual";
bool escenaActiva = false;

// EEPROM - Estableceer direcciones de memoria
const int DIR_FAN = 0;
const int DIR_PUERTA = 1;
const int DIR_ESCENA_ACTIVA = 2; 
const int DIR_FLAG_CONTROL = 10;// Direcci칩n para saber si ya hay datos
const byte VALOR_MAGICO = 123;

// Variables Para el Sistema de Escenas
bool modoCarga = false;
String nombreNuevaEscena = "";

const int MAX_ESCENAS = 4;
const int MAX_PASOS = 30;
const int ESPACIO_POR_ESCENA = 210;
const int DIR_ESCENAS_BASE = 100;
struct PasoEscena{
  byte pin;
  bool estado;
  unsigned int duracion; // en milisegundos
  byte repeticiones;
};
struct DatosEscena {
  char nombre[10];
  int totalPasos;
  PasoEscena pasos[MAX_PASOS];
};

PasoEscena pasosEscena[MAX_PASOS]; // Arreglo Unidimensional o lo que llamamos normalmente vector 
int totalPasos = 0;
int idEscenaActiva=0;

unsigned long tiempoUltimoPaso = 0;
int pasoActual = 0;
int repeticionActual = 0;


void setup() {
  // Inicializar el puerto serial
  Serial.begin(9600);

  // Configurar los pines creados anteriormente de Salida
  pinMode(PIN_SALA, OUTPUT);  
  pinMode(PIN_COMEDOR, OUTPUT);  
  pinMode(PIN_COCINA, OUTPUT);  
  pinMode(PIN_BANO, OUTPUT);  
  pinMode(PIN_HAB, OUTPUT);  
  pinMode(PIN_FAN, OUTPUT);  

  // Inicializar el periferico de Servo y LCD
  puertaServo.attach(PIN_SERVO);
  lcd.init();
  lcd.backlight();

  // Recuperacion del estado de la EEPROM
  recuperarEstado();
  actualizarLCD();
  if (EEPROM.read(DIR_FLAG_CONTROL) != VALOR_MAGICO) {
    Serial.println(F("EEPROM Vac칤a. Cargando escenas de f치brica..."));
    inicializarEscenasBase();
    // No marcamos el VALOR_MAGICO todav칤a para que si el usuario 
    // guarda una propia, entonces s칤 se considere "iniciada".
  }else {
    Serial.println(F("Escenas de usuario detectadas. Cargando cat치logo..."));
    // Aqu칤 puedes llamar a una rutina que cuente cu치ntas hay guardadas
  }
  // Mensajes a mostrar
  Serial.println(F("*** CASA AUTOMATIZADA DIC 2025 ***"));
  Serial.println(F("\n"));
}

void loop() {

  // Para manejar el ingreso comandos
  if (Serial.available() > 0){
    comando = Serial.readStringUntil('\n'); 
    comando.trim();
    comando.toUpperCase();
    interpretarComando(comando);
  }
 
  // Para manejar escenas activas , ejecutarlas.
  if (escenaActiva){
    ejecutarEscenaNonBlocking();
  }

}


void ejecutarEscenaNonBlocking() {
  if (!escenaActiva || totalPasos == 0) return;

  unsigned long tiempoActual = millis();
  
  if (tiempoActual - tiempoUltimoPaso >= pasosEscena[pasoActual].duracion) {
    
    // --- MEJORA PARA PARPADEO ---
    // Si tiene m치s de 1 repetici칩n, invertimos el estado en cada ciclo
    if (pasosEscena[pasoActual].repeticiones > 1) {
      // Leemos el estado actual del pin y lo invertimos
      bool estadoActual = digitalRead(pasosEscena[pasoActual].pin);
      digitalWrite(pasosEscena[pasoActual].pin, !estadoActual);
    } else {
      // Si es solo 1 repetici칩n, ponemos el estado que dice la escena
      digitalWrite(pasosEscena[pasoActual].pin, pasosEscena[pasoActual].estado);
    }
    
    repeticionActual++;

    // Si terminamos las repeticiones de este paso
    if (repeticionActual >= pasosEscena[pasoActual].repeticiones) {
      // Antes de irnos, aseguramos que el pin quede en el estado final deseado
      digitalWrite(pasosEscena[pasoActual].pin, pasosEscena[pasoActual].estado);
      
      repeticionActual = 0;
      pasoActual++; 
    }

    if (pasoActual >= totalPasos) {
      pasoActual = 0; 
      //escenaActiva = false;
      Serial.println(F("Escena Finalizada"));
    }
    
    tiempoUltimoPaso = tiempoActual;
  }
}

void eliminarTodasLasEscenas() {
  Serial.println(F("Borrando memoria de escenas..."));
  
  // Opci칩n A: Resetear el flag de control para que en el pr칩ximo reinicio cargue f치brica
  EEPROM.update(DIR_FLAG_CONTROL, 0xFF); // 0xFF es el valor de f치brica (255)
  
  // Opci칩n B: Limpiar f칤sicamente los slots (opcional pero recomendado)
  for (int i = 0; i < (MAX_ESCENAS * ESPACIO_POR_ESCENA); i++) {
    EEPROM.update(DIR_ESCENAS_BASE + i, 0);
  }
  
  Serial.println(F("Sistema reseteado. Reinicia el Arduino para cargar valores de f치brica."));
}

void interpretarComando(String cmd){
  // Flujo de control del comando
  
  // Control de comandos de luces
  if (cmd == "L1" || cmd == "L1ON") { digitalWrite(PIN_SALA,HIGH); Serial.println(F("SALA:ON")); }
  else if (cmd == "L1OFF") { digitalWrite(PIN_SALA,LOW); Serial.println("SALA:OFF"); }
  else if (cmd == "L2" || cmd == "L2ON") { digitalWrite(PIN_COMEDOR,HIGH); Serial.println("COMEDOR:ON"); }
  else if (cmd == "L2OFF") { digitalWrite(PIN_COMEDOR,LOW); Serial.println("COMEDOR:OFF"); }
  else if (cmd == "L3" || cmd == "L3ON") { digitalWrite(PIN_COCINA,HIGH); Serial.println("COCINA:ON"); }
  else if (cmd == "L3OFF") { digitalWrite(PIN_COCINA,LOW); Serial.println("COCINA:OFF"); }
  else if (cmd == "L4" || cmd == "L4ON") { digitalWrite(PIN_BANO,HIGH); Serial.println("BANO:ON"); }
  else if (cmd == "L4OFF") { digitalWrite(PIN_BANO,LOW); Serial.println("BANO:OFF"); }
  else if (cmd == "L5" || cmd == "L5ON") { digitalWrite(PIN_HAB,HIGH); Serial.println("HAB:ON"); }
  else if (cmd == "L5OFF") { digitalWrite(PIN_HAB,LOW); Serial.println("HAB:OFF"); }
  else if (cmd == "ALLON") { allOn(); Serial.println("TODAS:ON"); }
  else if (cmd == "ALLOFF") { allOff(); Serial.println("TODAS:OFF"); }

  // Control de comandos de motor
  else if (cmd == "FAN0") { setVentilador(0); }
  else if (cmd == "FAN1") { setVentilador(20); }
  else if (cmd == "FAN2") { setVentilador(40); }
  else if (cmd == "FAN3") { setVentilador(60); }

  // Control de la puerta
  else if (cmd == "DOOR") { togglePuerta(); }
  else if (cmd == "DOOROPEN") { moverPuerta(true); }
  else if (cmd == "DOORCLOSE") { moverPuerta(false); }

  // Control de Escenas
  else if (cmd == "FIESTA") { cargarEscenaDesdeSlot(1); }
  else if (cmd == "RELAX") { cargarEscenaDesdeSlot(2); }
  else if (cmd == "NIGHT") { cargarEscenaDesdeSlot(3); }

  // Control de Cargo de Escenas
  else if (cmd == "LOAD_SCENA") {
    modoCarga = true;
    totalPasos = 0;
    Serial.println(F("* MODO CARGA ACTIVADO *"));
    Serial.println(F("Agrega tus lineas del .org, debe terminar con END_LOAD NOMBRE"));
  }
  else if(cmd.startsWith("END_LOAD")){
    nombreNuevaEscena = cmd.substring(9);
    nombreNuevaEscena.trim();
    
    int slot = 1; // Default
    if(nombreNuevaEscena.equalsIgnoreCase("Relax")) slot = 2;
    else if(nombreNuevaEscena.equalsIgnoreCase("Noche") || nombreNuevaEscena.equalsIgnoreCase("Night")) slot = 3;
    
    // Llamamos a la versi칩n optimizada que no usa DatosEscena en RAM
    guardarEscenaEnSlot(slot, nombreNuevaEscena);
    Serial.println(F("* MODO CARGA FINALIZADO *"));
    modoCarga = false;
  }
  else if(modoCarga){
    procesarLineaEscena(cmd);
  }
  
  //ERASE_SCENES
  else if(cmd == "ERASE_SCENES"){
    eliminarTodasLasEscenas();
  }
  else if (cmd.startsWith("SHOW_SCENE ")) {
    Serial.println(F("* SHOW_SCENE *"));
    String nombre = cmd.substring(11); // Extrae lo que sigue despu칠s de "SHOW_SCENE "
    nombre.trim();
    int slot=1;
    if(nombre.equalsIgnoreCase("Relax"))
      slot=2;
    if(nombre.equalsIgnoreCase("Noche") || nombre.equalsIgnoreCase("Night"))
      slot=3;
    imprimrEscenaDesdeSlot(slot);
  }
  // Control del Sistema
  else if(cmd == "STOP"){
    escenaActiva = false;
    nombreEscena = "Manual";
    pasoActual = 0;                // Reinicia el 칤ndice de pasos
    repeticionActual = 0;          // Reinicia el contador de repeticiones
    tiempoUltimoPaso = 0;          // Resetea el cron칩metro
    idEscenaActiva=0;
    EEPROM.update(DIR_ESCENA_ACTIVA, idEscenaActiva);
    Serial.println("ESCENA DETENIDA");
  }
  else if(cmd == "STATUS"){ imprimirEstado(); }
  else if(cmd == "RESET"){ resetSistema(); }
  else if(cmd == "LIST_SCENES"){ listarEscenas(); }
  else if(cmd == "VERSION"){ Serial.println("Casa Dic2025"); }
  else {Serial.println("--> Comando Desconocido 游땩");}

  actualizarLCD();
  guardarEstadoActual();

}

void setVentilador (int pwm){
  digitalWrite(pinIN1,HIGH);
  digitalWrite(pinIN2,LOW);
  analogWrite(PIN_FAN, pwm);
  velocidadFan = pwm;
  Serial.print("FAN: "); Serial.println(pwm);
}

void moverPuerta(bool abrir){
  puertaAbierta = abrir;
  puertaServo.write(abrir ? 90:0);
  Serial.print("PUERTA: "); Serial.println(abrir ? "ABIERTA" : "CERRADA");
}

void togglePuerta(){ moverPuerta(!puertaAbierta); }

void allOn(){
  digitalWrite(PIN_SALA, HIGH);
  digitalWrite(PIN_COMEDOR, HIGH);
  digitalWrite(PIN_COCINA, HIGH);
  digitalWrite(PIN_BANO, HIGH);
  digitalWrite(PIN_HAB, HIGH);
}

void allOff(){
  digitalWrite(PIN_SALA, LOW);
  digitalWrite(PIN_COMEDOR, LOW);
  digitalWrite(PIN_COCINA, LOW);
  digitalWrite(PIN_BANO, LOW);
  digitalWrite(PIN_HAB, LOW);
}

//# Escena: FIESTA
//# Descripcion: Luces parpadeando rapidamente en patron alternado
//# Duracion total aproximada: 20 segundos
//
//SALA:ON:500:20  // pos1= SALA  pos2 =ON pos3= 500 pos3+1= 20
//COMEDOR:OFF:500:20
//COCINA:ON:300:30
//BA칌O:OFF:300:30
//HABITACION:ON:200:50

void procesarLineaEscena(String linea){ 
  linea.trim();
  // Estructurar posiciones de la linea
  if (linea.startsWith("#") || linea.length() == 0) return;
  if (totalPasos >= MAX_PASOS) {
    Serial.println(F("Error: Limite de pasos alcanzado"));
    return;
  }
  int pos1 = linea.indexOf(':');
  int pos2 = linea.indexOf(':', pos1 + 1);
  int pos3 = linea.indexOf(':', pos2 + 1);

  // Obtener datos del Ambiente
  if(pos1 > 0 && pos2 > pos1 && pos3 > pos2 && totalPasos < 50 ){
    String amb = linea.substring(0, pos1);
    String est = linea.substring(pos1 + 1, pos2);
    int dur = linea.substring(pos2 + 1, pos3).toInt();
    int rep = linea.substring(pos3 + 1).toInt();

    // Mapeo de Ambiente a pin
    byte pin = getPinFromAmbiente(amb);
    if(pin > 0){
      pasosEscena[totalPasos].pin = pin;
      pasosEscena[totalPasos].estado = (est == "ON");
      pasosEscena[totalPasos].duracion = dur;
      pasosEscena[totalPasos].repeticiones = rep;
      totalPasos++;
      Serial.print(F(" -> Linea Agregada"));
    }
  }
}

byte getPinFromAmbiente(String amb){
  if(amb == "SALA") return PIN_SALA;
  if(amb == "COMEDOR") return PIN_COMEDOR;
  if(amb == "COCINA") return PIN_COCINA;
  if(amb == "BANO") return PIN_BANO;
  if(amb == "HABITACION" || amb == "HAB") return PIN_HAB;
  return 0;
}

void guardarEscenaEnSlot(int slot, String nombre) {
  if (slot < 1 || slot > 3) return;

  // Calculamos la direcci칩n base del slot (0, 1 o 2 en memoria)
  int direccion = DIR_ESCENAS_BASE + ((slot - 1) * sizeof(DatosEscena));

  // 1. Guardar el nombre (10 bytes)
  char tempNombre[10];
  nombre.toCharArray(tempNombre, 10);
  for(int i = 0; i < 10; i++) {
    EEPROM.update(direccion + i, tempNombre[i]);
  }

  // 2. Guardar el total de pasos (2 bytes)
  EEPROM.put(direccion + 10, totalPasos);

  // 3. Guardar los pasos desde el array global paso a paso
  int addrPasos = direccion + 12;
  for(int i = 0; i < totalPasos; i++) {
    // Escribimos directamente cada struct de 5 bytes
    EEPROM.put(addrPasos + (i * sizeof(PasoEscena)), pasosEscena[i]);
  }

  // Marcamos que ya hay datos de usuario
  EEPROM.update(DIR_FLAG_CONTROL, VALOR_MAGICO);
  
  Serial.print(F("OK: Escena '")); Serial.print(nombre);
  Serial.print(F("' guardada en Slot ")); Serial.println(slot);
}

void cargarEscenaDesdeSlot(int slot) {
if (slot < 1 || slot > 3) return; 

  int direccion = DIR_ESCENAS_BASE + ((slot - 1) * sizeof(DatosEscena));
  
  // 1. Leer el nombre directamente byte a byte (ahorra RAM)
  char tempNombre[10];
  for(int i=0; i<10; i++) {
    tempNombre[i] = EEPROM.read(direccion + i);
  }
  nombreEscena = String(tempNombre);

  // 2. Leer el total de pasos (est치 despu칠s del nombre, offset 10)
  EEPROM.get(direccion + 10, totalPasos);
  if(totalPasos > MAX_PASOS) totalPasos = MAX_PASOS;

  // 3. Leer los pasos uno por uno al array global
  int addrPasos = direccion + 12; // nombre(10) + int(2)
  for(int i = 0; i < totalPasos; i++) {
    EEPROM.get(addrPasos + (i * sizeof(PasoEscena)), pasosEscena[i]);
  }

  pasoActual = 0;
  repeticionActual = 0;
  escenaActiva = true;
  idEscenaActiva = slot;
  Serial.print(F("Escena '")); Serial.print(nombreEscena);
  Serial.println(F("' cargada y activada."));
}
void imprimrEscenaDesdeSlot(int slot) {
  // Ajuste de slot 1-3 a 칤ndice 0-2 para la memoria
  if (slot < 1 || slot > 3) {
    Serial.println(F("Error: Slot fuera de rango (1-3)"));
    return;
  }

  int direccion = DIR_ESCENAS_BASE + ((slot - 1) * sizeof(DatosEscena));
  
  // Leemos solo el entero de totalPasos (offset 10)
  int pasosEnMemoria;
  EEPROM.get(direccion + 10, pasosEnMemoria);
  
  if (pasosEnMemoria <= 0 || pasosEnMemoria > MAX_PASOS) {
    Serial.println(F("Slot vacio o corrupto."));
    return;
  }

  Serial.println(F("\n--- CONTENIDO DE LA EEPROM ---"));
  Serial.println(F("PASO | AMBIENTE | ESTADO | DURACION | REP"));

  int addrPasos = direccion + 12; // nombre(10) + totalPasos(2)
  
  for(int i = 0; i < pasosEnMemoria; i++) {
    PasoEscena p;
    // Leemos solo UN paso (5 bytes) a la vez
    EEPROM.get(addrPasos + (i * sizeof(PasoEscena)), p);

    Serial.print(i + 1); Serial.print(F(":"));
    Serial.print(getNombrePin(p.pin)); Serial.print(F(":"));
    Serial.print(p.estado ? F("ON ") : F("OFF")); Serial.print(F(":"));
    Serial.print(p.duracion); Serial.print(F(":"));
    Serial.println(p.repeticiones);
  }
  Serial.println(F("------------------------------"));
}

// Funci칩n auxiliar para nombres legibles sin usar Strings pesados
String getNombrePin(byte pin) {
  if (pin == PIN_SALA)    return F("SALA ");
  if (pin == PIN_COMEDOR) return F("COMED");
  if (pin == PIN_COCINA)  return F("COCIN");
  if (pin == PIN_BANO)    return F("BANO ");
  if (pin == PIN_HAB)     return F("HABIT");
  return F("UNKNW");
}

void agregarPaso(byte pin, bool estado, unsigned int duracion, byte repeticiones) {
  if (totalPasos < MAX_PASOS) {
    pasosEscena[totalPasos].pin = pin;
    pasosEscena[totalPasos].estado = estado;
    pasosEscena[totalPasos].duracion = duracion;
    pasosEscena[totalPasos].repeticiones = repeticiones;
    totalPasos++;
  }
}
void inicializarEscenasBase() {
  Serial.println("--- Generando Escenas Predefinidas ---");

  // --- ESCENA 0: FIESTA (Parpadeo psicod칠lico) ---
  totalPasos = 0; 
  agregarPaso(PIN_SALA, HIGH, 200, 1);
  agregarPaso(PIN_COMEDOR, HIGH, 200, 1);
  agregarPaso(PIN_SALA, LOW, 200, 1);
  agregarPaso(PIN_COMEDOR, LOW, 200, 1);
  agregarPaso(PIN_COCINA, HIGH, 150, 2); // Parpadea 2 veces r치pido
  agregarPaso(PIN_COCINA, LOW, 150, 2);
  guardarEscenaEnSlotSilencioso(0, "FIESTA");

  // --- ESCENA 1: RELAX (Luces tenues y cambios lentos) ---
  totalPasos = 0;
  agregarPaso(PIN_SALA, HIGH, 5000, 1);   // Sala encendida mucho tiempo
  agregarPaso(PIN_HAB, HIGH, 3000, 1);    // Habitaci칩n suave
  agregarPaso(PIN_COCINA, LOW, 1000, 1);  // Cocina apagada
  guardarEscenaEnSlotSilencioso(1, "RELAX");

  // --- ESCENA 2: NIGHT (Modo ahorro/seguridad) ---
  totalPasos = 0;
  agregarPaso(PIN_SALA, LOW, 500, 1);     
  agregarPaso(PIN_COMEDOR, LOW, 500, 1);
  agregarPaso(PIN_COCINA, LOW, 500, 1);
  agregarPaso(PIN_BANO, LOW, 500, 1);
  agregarPaso(PIN_HAB, HIGH, 10000, 1);   // Solo habitaci칩n prendida
  guardarEscenaEnSlotSilencioso(2, "NIGHT");

  Serial.println(F("--- Escenas Guardadas Exitosamente ---"));
}
void guardarEscenaEnSlotSilencioso(int slot, String nombre) {
  int direccion = DIR_ESCENAS_BASE + (slot * sizeof(DatosEscena));
  
  // Guardar nombre
  char tempNombre[10];
  nombre.toCharArray(tempNombre, 10);
  for(int i=0; i<10; i++) EEPROM.update(direccion + i, tempNombre[i]);

  // Guardar total de pasos
  EEPROM.put(direccion + 10, totalPasos);

  // Guardar pasos uno por uno desde el array global
  int addrPasos = direccion + 12;
  for(int i = 0; i < totalPasos; i++) {
    EEPROM.put(addrPasos + (i * sizeof(PasoEscena)), pasosEscena[i]);
  }
}

void recuperarEstado(){
  velocidadFan = EEPROM.read(DIR_FAN);
  puertaAbierta = EEPROM.read(DIR_PUERTA);
  int escenaId = EEPROM.read(DIR_ESCENA_ACTIVA);
  setVentilador(velocidadFan);
  moverPuerta(puertaAbierta);
  // Solo cargar si es un ID v치lido (1, 2 o 3)
  Serial.println(F("escenaId: "));Serial.print(escenaId);
  if (escenaId >= 1 && escenaId <= 3) {
    cargarEscenaDesdeSlot(escenaId);
  } else {
    nombreEscena = "Manual";
    escenaActiva = false;
  }
  Serial.println(F("Estado Recuperado"));

}

void guardarEstadoActual(){
  EEPROM.update(DIR_FAN, velocidadFan);
  EEPROM.update(DIR_PUERTA, puertaAbierta);
  if(escenaActiva)
    EEPROM.update(DIR_ESCENA_ACTIVA, idEscenaActiva); 
}

void actualizarLCD(){
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Escena: ");
  lcd.print(nombreEscena);

  lcd.setCursor(0,1);
  if (velocidadFan == 0) lcd.print("FAN:OFF");
  else if (velocidadFan < 100) lcd.print("FAN:LOW");
  else lcd.print("FAN:HI");

  lcd.print(puertaAbierta ? "P:ABR" : "P:CER");
}

void imprimirEstado(){
  Serial.println(F("*** ESTADO ACTUAL DEL SISTEMA ***"));
  Serial.print(F("SALA : ")); Serial.println(digitalRead(PIN_SALA) ? "ON" : "OFF");
  Serial.print(F("COMEDOR : ")); Serial.println(digitalRead(PIN_COMEDOR) ? "ON" : "OFF");
  Serial.print(F("COCINA : ")); Serial.println(digitalRead(PIN_COCINA) ? "ON" : "OFF");
  Serial.print(F("BANO : ")); Serial.println(digitalRead(PIN_BANO) ? "ON" : "OFF");
  Serial.print(F("HAB : ")); Serial.println(digitalRead(PIN_HAB) ? "ON" : "OFF");
  Serial.print(F("FAN : ")); Serial.println(velocidadFan);
  Serial.print(F("PUERTA : ")); Serial.println(puertaAbierta ? "ON" : "OFF");
  Serial.print(F("ESCENA : ")); Serial.println(nombreEscena);
}

void resetSistema(){
  allOff();
  setVentilador(0);
  moverPuerta(false);
  escenaActiva = false;
  nombreEscena = "Reset";
  idEscenaActiva=0;
  Serial.println(F("*** Sistema Reiniciado ***"));
}

void listarEscenas() {
  Serial.println(F("\n*** CATALOGO DE ESCENAS ***"));
  for(int i = 1; i <= 3; i++) {
    int direccion = DIR_ESCENAS_BASE + ((i - 1) * sizeof(DatosEscena));
    char nombreTemp[10];
    
    // Leemos solo el nombre de cada slot
    for(int j = 0; j < 10; j++) {
      nombreTemp[j] = EEPROM.read(direccion + j);
    }
    
    Serial.print(F(" Slot ")); Serial.print(i);
    Serial.print(F(": ")); Serial.println(nombreTemp);
  }
}

